import {
  Title,
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import {
  base,
  duotoneLight,
  github,
  vsDark,
  nightOwl,
} from "@code-surfer/themes";
import just from './src/images/just.png'
import justMap from './src/images/just_map.png'
import nothing from './src/images/nothing.png'
import nothingMap from './src/images/nothing_map.png'

# Hello FP in JS - 3 👋

<div>FE개발팀</div>
<div>Nakta</div>

---

# 오늘 살펴볼 내용

## Applicative Functor

<Notes>

오늘은 Applicative Functor 하나만 설명하고 끝내도록 하겠습니다. 

Functor는 Functor인데 살짝 다른 펑터입니다.

그럼 펑터를 이해하고 있어야 하는데 기억이 잘 안날수도 있으니 다시 한번 살짝 살펴볼게요.

</Notes>


---

## Functor 다시 보기

- Box 안에 값을 가진 형태
- map 함수를 통해서 Box 안에 있는 값을 변경

<Notes>

펑터는 박스 안에 어떤 값을 넣을 수 있는 객체였습니다.
그리고 이 값을 변경하고 싶을때는 map 메소드를 이용해서 박스 형태를 유지한채로 값을 변경했습니다.

</Notes>

---

<CodeSurferColumns themes={[base, duotoneLight]}>

<Step title="Maybe Functor: Just">

<Image src={just} width="200px" height="240px" />

Box 안에 정상적인 값이 들어있는 경우

</Step>

<Step title="Maybe Functor: Nothing">

<Image src={nothing} width="200px" height="240px" />

Box 안에 값이 undefined나 null인 경우

</Step>

</CodeSurferColumns>

<Notes>

펑터 중에 에러 처리를 위한 펑터인 Maybe로 설명을 다시 드리면, 박스 안에 정상적인 값이 있는 경우 Just가 됩니다. 이 그림에서는 박스 안에 2라는 값을 넣은 상태입니다.

그리고 박스 안에 undefined나 null이 들어간 경우 Nothing 이 됩니다.

</Notes>

---

<CodeSurferColumns themes={[base, duotoneLight]}>

<Step title="Maybe Functor: Just map">

<Image src={just} width="200px" height="240px" />

```jsx file=./src/Functor/just-1.js
```

</Step>

<Step title="Maybe Functor: Just map">

<Image src={justMap} width="750px" height="240px" />

```jsx file=./src/Functor/just-2.js
```

</Step>

<Step title="Maybe Functor: Nothing map">

<Image src={nothingMap} width="750px" height="240px" />

```jsx file=./src/Functor/nothing.js
```

</Step>

</CodeSurferColumns>

<Notes>

박스 안에 들어있는 값을 변경하고 싶을 때는 map 메소드를 사용하는데요.

addThree라는 함수가 있고 이 함수를 map 메소드에 넘겨주면 박스 안에 있던 2라는 숫자에 3을 더해서 5가 들어있는 박스가 반환됩니다.

그리고 Nothing 상태인 박스에 map 메소드를 사용하는 경우 아무것도 발생하지 않습니다. Nothing 상태 그대로 유지가 됩니다. 여기까지가 펑터의 특성이었는데 이걸 베이스로 Applicative Functor를 설명 드리도록 할게요.

</Notes>

---

<CodeSurferColumns themes={[base, duotoneLight]}>

<Step>

```markdown 1 title="요구사항"
1. id를 이용해서 책 두 권 찾기
2. 책의 제목을 하나로 합쳐서 반환
```

```js file=./src/example-1.js
```

</Step>

<Step>

```markdown 2 title="요구사항"
1. id를 이용해서 책 두 권 찾기
2. 책의 제목을 하나로 합쳐서 반환
```

```js file=./src/example-2.js
```

</Step>

</CodeSurferColumns>

<Notes>

늘 하던대로 예제를 보면서 설명 드릴텐데요.

이번 예제도 책을 활용한 예제입니다.

이번에는 책 두 권을 찾아서 이 두권의 책 제목을 하나로 합쳐서 반환해주면 됩니다.

</Notes>

---

<CodeSurfer>

```jsx file=./src/applicative/1.js title="findBookById()"
```

```jsx file=./src/applicative/2.js title="findBookById()"
```

```jsx file=./src/applicative/3.js title="findBookById()"
```

```jsx file=./src/applicative/4.js title="findBookById()"
```

</CodeSurfer>

<Notes>

책을 찾아줄 findBookById 함수를 만듭니다. 파라미터로 책 목록과 찾고 싶은 책 아이디를 받아서 처리해주면 될것 같습니다.

책 목록에서 find 메소드를 사용하는데 predicate 함수에 propEq 헬퍼 함수를 사용해서 일치하는 책을 찾아줍니다. 이때 id에 해당하는 책이 없다면 Undefined가 반환되기 때문에 Maybe.of 를 사용해서 Maybe 펑터로 감싸줍니다.

그런데 지금 함수 호출이 중첩으로 들어가기 때문에 파이프 함수를 사용해서 조금더 읽기 편하게 바꿔줍니다.

이제 findBookById를 사용하면 id에 해당하는 값이 있는 경우 Just가 반환되구요, 책이 없는 경우는 Nothing이 반환 됩니다.

</Notes>

---

<CodeSurfer>

```jsx 12:14 file=./src/applicative/5.js title="concatBooksTitle()"
```

```jsx file=./src/applicative/6.js title="concatBooksTitle()"
```

</CodeSurfer>

<Notes>

이제 다음 단계는 책 제목을 하나로 합쳐줘야 겠죠. 우선 concatBooksTitle 함수를 만들어 줍니다.

그리고 두 책의 제목을 하나로 합쳐줍니다. 이제 대강 필요한 함수는 다 만들었기 때문에 조합을 해줍니다.
</Notes>

---

<CodeSurfer>

```jsx 5[7:19],12[7:23] file=./src/applicative/6.js title="fidnBookById + concatBooksTtitle"
```

```jsx 12[33:44],16,17 file=./src/applicative/7.js title="fidnBookById + concatBooksTtitle"
```

```jsx file=./src/applicative/8.js title="fidnBookById + concatBooksTtitle"
```

```jsx file=./src/applicative/9.js title="fidnBookById + concatBooksTtitle"
```

</CodeSurfer>


<Notes>
책은 `findBookById`를 사용해서 찾을 수 있습니다. 그리고 책 두 권을 찾아서 `concatBooksTitle` 함수에 넘겨주면 원하는 결과를 얻을 수 있겠죠.

근데 문제는 `findBookById` 반환 값이 Maybe인데, `concatBooksTitle`에서는 Maybe가 아니라 책을 받아야 합니다. 

그럼 Maybe 안에 있는 책을 꺼내주면 되겠네요. 기억나실지 모르겠지만 getOrEls 를 사용하면 Maybe 안에 있는 값을 꺼낼 수 있습니다.

이제 concatBooksTitle 함수에 넣어주면 원하는 요구사항은 끝입니다.
</Notes>

---

<CodeSurfer>

```jsx 16:22 file=./src/applicative/9.js title="fidnBookById + concatBooksTtitle"
```

```jsx file=./src/applicative/10.js title="fidnBookById + concatBooksTtitle"
```

```jsx file=./src/applicative/11.js title="fidnBookById + concatBooksTtitle"
```

```jsx file=./src/applicative/12.js title="fidnBookById + concatBooksTtitle"
```

</CodeSurfer>

<Notes>

그런데 여기서 문제가 되는 부분이 또 있거든요. 어딘지 아시려나요?

만약 책을 찾지 못하게 된다면, findBookById의 결과가 Nothing이 됩니다.

그리고 getOrElse를 하면 Nothing일때 반환해줄 null 이 반환되겠죠.

book3를 두 번째 파라미터에 넣어주면, 이렇게 타입 에러가 발생합니다. 사실 Maybe를 사용하는 이유는 에러처리를 하기 위한건데, getOrElse를 로직 중간에 사용하니까 에러 처리 대응이 안되는 상황이 나온건데요. getOrElse 대신 다른 방법을 사용하도록 하겠습니다.

</Notes>

---

<CodeSurferColumns themes={[base, duotoneLight]}>

<Step title="fidnBookById + concatBooksTtitle">

```jsx 21:23 file=./src/applicative/13-functor.js subtitle="Functor map"
```

```jsx 21:23 file=./src/applicative/13-monad.js subtitle="Monad chain"
```

</Step>

<Step title="fidnBookById + concatBooksTtitle">

```jsx file=./src/applicative/14-functor.js subtitle="Functor map"
```

```jsx file=./src/applicative/14-monad.js subtitle="Monad chain"
```

</Step>

<Step title="fidnBookById + concatBooksTtitle">

```jsx file=./src/applicative/15-functor.js subtitle="Functor map"
```

```jsx file=./src/applicative/15-monad.js subtitle="Monad chain"
```

</Step>

<Step title="fidnBookById + concatBooksTtitle">

```jsx diff 30 file=./src/applicative/15-functor.js
```

```jsx 21:25 file=./src/applicative/15-monad.js subtitle="Monad chain"
```

</Step>


<Step title="fidnBookById + concatBooksTtitle">

```jsx diff 30 file=./src/applicative/15-functor.js
```

```jsx 16:32 file=./src/applicative/16.js subtitle="Monad chain"
```

</Step>


</CodeSurferColumns>

<Notes>

기억나실지 모르겠지만 Maybe는 펑터이면서 모나드가 되기도 합니다. 그래서 Maybe안에 들어있는 값에 접근하는 방법이 두가지가 있었습니다. 하나는 펑터 메소드인 map이고 또 하나는 모나트 메소드인 chain 입니다. 지금 보시면 왼쪽은 map을 사용했고, 오른쪽은 chain을 사용해서 각자 book1에 접근할 수 있게 됐습니다.

두 번째 책에도 접근하기 위해서 다시 한번 중첩으로 사용하면 되겠죠.

그리고 boo1, book2 모두 접근가능한 상황이 됐으니 마지막으로 concatBooksTitle을 해주면 원하는 결과를 얻을 수 있습니다. 여기서 Functor를 사용하는 경우는 findBookById가 Maybe를 반환하기 때문에 중첩으로 사용된 만큼 Just 개수가 겹쳐지게 됩니다. 반면에 모나드를 사용한 코드를 보면 모나드는 중첩 구조를 눌러 펴주는 기능을 하기 때문에 Just 한겹만 남게 됩니다.

그럼 여기서 저희 선택지는 당연히 모나드 쪽이겠죠. 근데 문제는 코드가 너무 복잡해서 읽기도 힘든 상태인데요. 이 부분을 개선해보도록 할게요.

</Notes>

---

<CodeSurfer>

```jsx 12[33:44],16,17 file=./src/applicative/17.js title="복잡한 로직 숨기기"
```

```jsx 16[30:34],17[41:45] file=./src/applicative/18.js title="복잡한 로직 숨기기"
```

```jsx 12[33:54] file=./src/applicative/19.js title="복잡한 로직 숨기기"
```

```jsx file=./src/applicative/20.js title="복잡한 로직 숨기기"
```

```jsx file=./src/applicative/21.js title="복잡한 로직 숨기기"
```

```jsx 12:18 file=./src/applicative/21.js title="복잡한 로직 숨기기" subtitle="복잡한 코드는 그대로 존재"
```

</CodeSurfer>

<Notes>

concatBooksTitle 함수의 파라미터는 책 객체를 받아서 처리하는데 우리가 찾는 책은 Maybe 안에 들어있는 형태밖에 없습니다.

그렇다보니 Maybe안에 들어있는 책 두권을 뽑아내기 위해서 chain을 사용할 수 밖에 없었죠.

자 그럼 생각을 살짝 바꿔서 concatBooksTitle 함수가 maybe를 받을 수 있다면 이런 복잡한 로직을 concatBooksTitle 함수 내부로 옮길 수 있을것 같습니다.

주요 로직을 concatBooksTItle 함수 내부로 이동시키면 이런 모양이 되겠죠.

바뀐 concatBooksTItle은 이렇게 간단하게 사용할 수 있게 됩니다.

하지만 원래복잡한 로직을 저렇게 함수안으로 숨겼을 뿐이지 중첩 chain 호출때문에 뎁스가 깊어지고 코드 가독성이 안좋은건 그대로입니다.

</Notes>

---

# Applicative Functor

함수를 품은 Functor

<Notes>

그래서 이런 문제를 해결하기 위해서 Applicative Functor를 사용해야 하는데요.

Applicative Functor는 여기 나와있는대로 펑터긴 펑터인데 함수를 값으로 가진 펑터라고 생각하면 간단합니다.

</Notes>

---

<CodeSurfer>

```js file=./src/applicative/22-applicative.js title="Applicative Functor"
```

```js file=./src/applicative/23-applicative.js title="Applicative Functor"
```

```js file=./src/applicative/24-applicative.js title="Applicative Functor" subtitle="addThree에 2를 파라미터로 호출"
```

```js file=./src/applicative/25-applicative.js title="Applicative Functor"
```

```js file=./src/applicative/25-applicative.js title="Applicative Functor" subtitle="코드 가독성 🤔"
```

```js file=./src/applicative/26-applicative.js title="Applicative Functor"
```

```js file=./src/applicative/27-applicative.js title="Applicative Functor" subtitle="코드 가독성 👍"
```

</CodeSurfer>

<Notes>

여기 addThree라는 함수가 있습니다.

방금 설명했던 대로 이 함수를 Maybe 안에 넣어보겠습니다

이제 Maybe안에 넣은 함수에다가 2를 파라미터로 넘겨서 호출하고 싶다고 한다면? 어떻게 해야 될까요?

Maybe 안에 들어있는 함수에 접근하기 위해서 map을 사용하고 여기서 addThree 함수에 2를 넘겨서 실행해줍니다.

그런데 뭔가 코드가 복잡해 보이죠.

그럼 함수를 먼저 넣지 않고 기존에 우리가 하던 방식대로 2를 먼저 Maybe에 넣어줍니다.

그리고 map을 이용해서 addThree를 넘겨주면 깔끔하죠. 즉, 이 map 메소드는 내부에 값이 일반적인 값일 때 유용하지만, 함수일때는 사용하기 어렵다는걸 알 수 있습니다.

</Notes>

---

<CodeSurfer>

```js 5:8 file=./src/applicative/27-applicative.js title="Applicative Functor"
```

```js file=./src/applicative/28-applicative.js title="Applicative Functor" subtitle="ap 메소드 추가"
```

```js file=./src/applicative/29-applicative.js title="Applicative Functor"
```

```js 9[26:36],13[1:18]  file=./src/applicative/29-applicative.js title="Applicative Functor" subtitle="this.\$value === addThree"
```

```js 9[26:34],13[1:18] file=./src/applicative/30-applicative.js title="Applicative Functor"
```

```js 8[8:12],14[4:18] file=./src/applicative/30-applicative.js title="Applicative Functor" subtitle="maybe === Maybe.of(2)"
```

```js file=./src/applicative/31-applicative.js title="Applicative Functor"
```

```js 9,16,17 file=./src/applicative/31-applicative.js title="Applicative Functor"
```

</CodeSurfer>

<Notes>

다시 돌아가서 Maybe에 함수를 넣은 경우도 map 메소드처럼 쉽게 사용할 수 있는 메소드를 하나 추가해보겠습니다.

Maybe 클래스 구현은 대충 생략을 해놨는데요, 여기에 추가한 메소드 이름은 ap 라는 이름을 갖습니다

이 ap 메소드는 이런 방식으로 사용하면 됩니다. 그러면 map과 거의 유사한 형태로 같은 결과를 얻을 수 있습니다. 이게 어떻게 동작하는지 하나씩 같이 살펴볼게요

우선 Maybe.of(addThree)를 실행하면 Maybe 안에 들어있는 $value는 addThree가 됩니다.

이걸 그대로 치환하면 이렇게 바꿔쓸 수 있겠죠.

다음으로 ap를 호출하면 ap 메소드의 파리미터는 Maybe.of(2) 가 되겠죠.

이 부분도 그대로 치환해서 쓰면 이렇게 됩니다.

자 그럼 어떤가요?? 아래 map을 사용하는 코드를 보면 완전 똑같은 모양을 갖게 됐습니다. 자 그럼 ap 구현이 map을 사용하는 형태랑 사실상 같은데 왜 추가가 됐을까요?

</Notes>

---

# Applicative Functor

함수를 품은 Functor

ap 메소드를 구현한 객체


<Notes>

우선 왜 필요한지 설명 드리기 전에 Applicative Functor에 대해서 하나 말씀 안드린 부분이 있엇는데요. 바로 applicative functor를 만족하려면 ap 메소드를 구현해야 한다는 부분입니다.

functor가 map 메소드가 있어야 하고, monad가 chain 메소드가 있어야 하듯!! Applicative functor는 ap라는 메소드를 가지고 있어야 합니다.

</Notes>

---

<CodeSurfer>

```js file=./src/applicative/32.js title="Applicative Functor"
```

</CodeSurfer>

<Notes>

방그 살펴봤듯이 map을 사용한 방식으로도 충분히 ap와 같은 효과를 볼 수 있는데 왜 이런 기능이 필요할까 생각하실 수 도 있을텐데요. 이 방금 추가한 ap는 펑터 2개를 파라미터로 받는 함수에서 강력한 기능을 합니다.

</Notes>

---

<CodeSurfer>

```js file=./src/applicative/33.js title="Applicative Functor"
```

```js file=./src/applicative/34.js title="Applicative Functor"
```

```js 10[27:52] file=./src/applicative/35.js title="Applicative Functor"
```

```js 10[27:52],11 file=./src/applicative/35.js title="Applicative Functor"
```

```js 7,10[27:52],11 file=./src/applicative/36.js title="Applicative Functor" subtitle="concatBooksTitle은 curry 함수"
```

```js file=./src/applicative/37.js title="Applicative Functor"
```

```js file=./src/applicative/38.js title="Applicative Functor"
```

```js 5:8 file=./src/applicative/34.js title="Applicative Functor"
```

</CodeSurfer>

<Notes>

아까 복잡한 로직을 숨겨서 구현했던 코드입니다. 이 코드를 ap 메소드를 사용해서 구현하보겠습니다.

ap를 사용하면 이렇게 구현할 수 있습니다. 어떤가요?? 가독성이 훨씬 좋아지지 않았나요? 이 코드가 어떻게 돌아가는지 한줄씩 한번 살펴보도록 할게요.

첫 번재 줄을 실행하면 Maybe 안에 concatBooksTitle 함수를 넣습니다.

그리고 여기에 ap메소드를 이용해서 Just(Book1) 을 넘겨줬습니다.

여기까지를 ap 메소드 구현 부에 치환시키면 이런 모습이 됩니다. 지금까지 코드를 실행하면 concatBooksTitle 함수에 book1을 파라미터로 넘겨서 실행하게 되겠죠.

그런데 concatBooksTItle은 커리 함수이고 파라미터 2개를 받아야 하기 때문에 Just 안에은 book2를 파라미터를 받을 수 있는 함수가 남아있게 됩니다. 이제 다시 한번 ap 메소드를 이용해서 Just(Book2)를 넘겨주면

concatBooksTitle에 두 번째 파라미터로 book2를 넘겨주면서 최종적으로 실행된 결과가 Just안에 들어간 형태가 됩니다

</Notes>

---

<CodeSurfer>

```js 5[27:52],6,7 file=./src/applicative/34.js title="Applicative Functor"
```

```js file=./src/applicative/39.js title="Applicative Functor"
```

```js file=./src/applicative/40.js title="Applicative Functor" subtitle="언어에 따라서 liftA2는 map2 라고 불리기도 함"
```

</CodeSurfer>

<Notes>

한가지 더 여기서 보시면 concatBooksTitle이 파라미터 2개가 필요하기 때문에 ap를 두번 실행해줬는데요. 어떻게 보면 이 영역까지가 하나의 세트로 생각할 수 있을것 같습니다.

그래서 어떤 함수를 실행하는데 두개의 펑터만 갖고 있는 상황이 오면 손쉽게 사용할 수 있도록 liftA2라는 함수를 하나 만들어줍니다.

이함수를 이용해서 다시 구현하면 이런 코드가 됩니다. 그러면 Maybe.of를 감싸주고, ap 메소드를 직접 호출해주지 않아도 손쉽게 사용할 수 있게 됩니다.

</Notes>

---

<CodeSurferColumns themes={[base, duotoneLight]}>

<Stpe title="Monad vs Applicative Fuctor">

```js subtitle="Moand"
findBookById(books, 'book1').chain((book1) => {
    return findBookById(books, 'book2').chain((book2) => {
        return concatBooksTitle(book1, book2);
    })
}).getOrElse('invalid book id');
```

```js subtitle="Applicative Functor"
liftA2(
    concatBooksTitle,
    findBookById(books, 'book1'),
    findBookById(books, 'book2')
).getOrElse('invalid book id')
```

</Stpe>


</CodeSurferColumns>

<Notes>

마지막으로 모나드로 구현했던 방식과, Applicative functor로 구현항 방식을 같이 보면 확실히 Applicative functor쪽이 코드가 깔끔하다는것을 알 수 있습니다. 자 이렇게 해서 파라미터가 두개 이상 필요한 함수가 있는데, 두 파라미터 모두 펑터 값만 있는 경우에 유용하게 사용할 수 있는 Applicative functor를 살펴봤습니다.

</Notes>

---

<CodeSurferColumns themes={[base, duotoneLight, github]}>

<Step title="일반 적인 값을 반환하는 함수 적용">

```js file=./src/applicative/41-functor.js subtitle="Functor"
```

```js 1 file=./src/applicative/41-monad.js
```

```js 1 file=./src/applicative/41-applicative.js
```

</Step>

<Step title="박스 형태를 반환하는 함수 적용">

```js 1 file=./src/applicative/41-functor.js
```

```js file=./src/applicative/41-monad.js subtitle="Monad"
```

```js 1 file=./src/applicative/41-applicative.js
```

</Step>

<Step title="파라미터가 2개 이상인 파라미터를 적용, 파라미터로 펑터만 갖고 있는 경우">

```js 1 file=./src/applicative/41-functor.js
```

```js 1 file=./src/applicative/41-monad.js
```

```js file=./src/applicative/41-applicative.js subtitle="Applicative Functor"
```

</Step>

</CodeSurferColumns>

<Notes>

이제 이런 개념이 3개정도 되니 헷갈릴 수 있는데요. 세가지 개념의 용도를 간단하게 보면
펑터는 박스 내부에 있는 값을 변경하고 싶은데, 실행시켜줄 함수가 박스 형태를 반환하지 않고 일반적인 값이나 오브젝트를 반환할때 사용합니다.

모나드도 박스 내부에 있는 값을 변경하고 싶은데, 싱행시켜줄 함수가 값이나 오브젝트가 아니라 박스 형태를 반환할때 사용합니다

Applicative functor는 파라미터가 두개 이상인 함수를 적용하고 싶은데, 박스 형태의 파라미터만 갖고 잇는 경우에 사용합니다

</Notes>

---

# Q & A

지난 발표자료 👉 https://adoring-leavitt-6c4667.netlify.app/

